import EaselJS from "masteryodaeaseljs";
import TweenJS from "masteryodatweenjs";
import {preloader} from "../index";
import MessageBar from '../utils/MessageBar';
import { hints as configMsgHints } from '../config/msg';
import { BaseMapInfo } from '../logic/ConstInfo';

class Element
{
    constructor(stage, size, n, animation)
    {
        this.size = size / n;
        this.n = n;
        this.wall = preloader.getResult("wall");
        this.coin = preloader.getResult("coin");
        this.treasure = preloader.getResult("treasure");
        this.animation = animation;
        this.stage = stage;
        this.reset()
    }

    reset()
    {
        this.container = null;
    }

    /**
     * draw ground and walls and cache them to improve performance
     * @param map generated by Controller.getMap()
     */
    init(map)
    {
        this.container = new EaselJS.Container();
        this.stage.addChild(this.container);

        this.coins = new EaselJS.Shape();
        this.treasures = new EaselJS.Shape();
        const info_arr = map.eData();
        const size_x = map.SIZE_X;
        const size_y = map.SIZE_Y;
        for (let i = 0; i < size_x; i++)
        {
            const screen_y = this.size * i;
            for (let j = 0; j < size_y; j++)
            {
                const screen_x = this.size * j;
                if (info_arr[i][j] === BaseMapInfo.getElementsByTagName("block"))
                {
                    this.paintWall(screen_x, screen_y);
                }
                else if (info_arr[i][j] === BaseMapInfo.getElementsByTagName("gold"))
                {
                    this.paintCoin(screen_x, screen_y);
                }
                else if (info_arr[i][j] === BaseMapInfo.getElementsByTagName("end"))
                {
                    this.paintFinish(screen_x, screen_y);
                }
            }
        }
        this.coins.cursor = "pointer";
        this.coins.shadow = new EaselJS.Shadow('#ffcb3d', 0, 0, 8);

        this.treasures.cursor = "pointer";
        this.treasures.shadow = new EaselJS.Shadow('#000000', 2, 2, 8);

        if (this.animation)
        {
            this.coins.on("mousedown", (ev) => {
                MessageBar.show(configMsgHints.clickCoin);
                const coins = ev.target;
                TweenJS.Tween.get(coins, {loop: 2})
                    .to({
                        alpha: 0.5,
                    }, 1000)
                    .to({
                        alpha: 1
                    }, 300);
            });
            this.treasures.on("mousedown", (ev) => {
                MessageBar.show(configMsgHints.clickTreasure);
                const treasure = ev.target;
                TweenJS.Tween.get(treasure, {loop: 2})
                    .to({
                        alpha: 0.5,
                    }, 1000)
                    .to({
                        alpha: 1
                    }, 300);
            });
        }
        this.container.addChild(this.coins);
        this.container.addChild(this.treasures);
    }

    /**
     * updates the coins on the background
     * @param map generated by Controller.getMap()
     */
    update(map)
    {
        if (this.container === null)
        {
            this.init(map);
        }

        this.coins.graphics.clear();
        this.treasures.graphics.clear();
        const info_arr = map.eData();
        const size_x = map.SIZE_X;
        const size_y = map.SIZE_Y;

        for (let i = 0; i < size_x; i++)
        {
            const screen_y = this.size * i;
            for (let j = 0; j < size_y; j++)
            {
                const screen_x = this.size * j;
                if (info_arr[i][j] === BaseMapInfo.getElementsByTagName("gold"))
                {
                    this.paintCoin(screen_x, screen_y);
                }
                else if (info_arr[i][j] === BaseMapInfo.getElementsByTagName("end"))
                {
                    this.paintFinish(screen_x, screen_y);
                }
            }
        }
    }

    updateN(n)
    {
        this.size = this.size * this.n;
        this.n = n;
        this.size = this.size / n;
    }

    /**
     * paint a block of wall given its upper-left point
     * @param screen_x horizontal ordinate of the upper-left point
     * @param screen_y vertical ordinate of the upper-left point
     */
    paintWall(screen_x, screen_y)
    {
        const wall = new EaselJS.Shape();
        wall.cursor = "pointer";
        if (this.animation)
        {
            wall.on("mousedown", (ev) => {
                MessageBar.show(configMsgHints.clickWall);
                const clickedWall = ev.target;
                TweenJS.Tween.get(clickedWall)
                    .to({
                        alpha: 0.1,
                        scaleX: 0.3,
                        scaleY: 0.3,
                    })
                    .to({
                        alpha: 0.5,
                        scaleX: 1,
                        scaleY: 1,
                    }, 1000, TweenJS.Ease.elasticOut)
                    .to({
                        alpha: 1
                    }, 300);
            });
        }

        const m = new EaselJS.Matrix2D();
        m.scale(this.size / this.wall.width, this.size / this.wall.height);
        wall.graphics.beginBitmapFill(this.wall, "no-repeat", m);

        wall.graphics.drawRect(0, 0, this.size, this.size);
        wall.shadow = new EaselJS.Shadow('#000', 4, 4, 8);

        wall.x = screen_x;
        wall.y = screen_y;
        wall.cache(0, 0, this.size, this.size);
        this.container.addChild(wall);
    }

    /**
     * paint a coin given the upper-left point of the block
     * @param screen_x horizontal ordinate of the center
     * @param screen_y vertical ordinate of the center
     */
    paintCoin(screen_x, screen_y)
    {
        const m = new EaselJS.Matrix2D();
        m.translate(screen_x, screen_y);
        m.scale(this.size / this.coin.width, this.size / this.coin.height);
        this.coins.graphics.beginBitmapFill(this.coin, "no-repeat", m);
        this.coins.graphics.drawCircle(screen_x + this.size / 2, screen_y + this.size / 2, this.size / 4);
    }

    /**
     * paint the finish point given the upper-left point of the block
     * now it is painted as a treasure chest
     * @param screen_x horizontal ordinate of the center
     * @param screen_y vertical ordinate of the center
     */
    paintFinish(screen_x, screen_y)
    {
        const m = new EaselJS.Matrix2D();
        const width = 0.7 * this.size;
        const height = 0.7 * this.size;
        m.translate(screen_x + (this.size - width) / 2, screen_y + (this.size - height) / 2);
        m.scale(width / this.treasure.width, height / this.treasure.height);
        this.treasures.graphics.beginBitmapFill(this.treasure, "no-repeat", m);

        this.treasures.graphics.drawRect(screen_x + (this.size - width) / 2, screen_y + (this.size - height) / 2, width, height);
    }
}

export default Element;
